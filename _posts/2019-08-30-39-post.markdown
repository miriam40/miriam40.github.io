---
layout: post
title:  "ITEM 39 :: EFFECTIVE C#"
subtitle: "function과 action 내에서는 예외가 발생하지 않도록 하라"
date:   2019-08-30 13:50:02
categories: [EffectiveC샵]
---

**안녕하세요, 39번째 시간입니다.**

___

이번 챕터는 function과 action 내에서는 예외가 발생하지 않도록 하라, 입니다.
이건 챕터명만 보고는 잘 모르겠네요. 
람다식을 사용할 땐 내부 예외가 발생했을 때 발견하기 어렵다는 내용과 매칭이 되는 것 같은데, 내용은 좀 더 들어가봐야 알겠네요.



## 설명


1. 일련의 값을 순차적으로 처리하는 코드의 중간 쯤에서 예외가 발생하면 이를 복구할 수 없는 문제가 존재한다. 어디까지 처리가 완료되었고, 문제가 어디서 발생하여 어디 부분을 원복해야 하는지도 알 수 없다. 따라서, 프로그램의 상태를 원복할 수 없는 큰 문제에 봉착하게 된다.

2. 이러한 메서드에서 예외를 발생하지 않도록 하려면 가장 쉬운 접근 방법은 람다 표현식으로 나타낸 액션 메서드가 절대 예외를 발생시키지 않도록 하는 것이다. 예를들어 시퀀스 내의 개별 요소들에 접근하여 요소들을 수정하기 이전에 오류 가능성을 미리 테스트해 볼 수 있다. 오류가 발생할 것 같으면 아예 특정 접근을 허용하지 않고 아무 작업도 안하게 작성할 수도 있다. 다만 그렇게 작성할 수 없는 경우도 있다.


3. 2번에서 처럼 작성할 수 없다면, 비용이 들더라도 강력한 방어 조취를 취해야 하는데, 알고리즘을 작성할 때 예외 발생 가능성을 염두에 두고 코드를 작성하는 것이다. 이는 책에서의 예에서와 같이 코드가 길어지고 관리해야하는 코드 양이 늘어나며 코드를 이해하기도 어려워지며, 응용프로그램의 성능에도 영향을 미친다. 또한 이 수정된 코드로 인해 추가 문제가 발생할 여지가 있다. 또한 다른 함수를 코드 내에서 조합하여 사용하기 힘들어진다.물론, 이 모든 변환과정을 한번에 수행할 수 있도록 쿼리를 작성하는 것을 고려해볼 수 있다. 이 경우 조합된 작업의 마지막 단계는 캐시된 전체 리스트로 기존 리스트를 대체하는 작업이 될 것인데, 이 방법을 사용하면 조합 가능성을 유지하면서도 예외가 발생하지 않게 코드를 작성할 수 있다.

4. 다만 이 방법은 기존 시퀀스의 개별 요소들을 수정해서 반환하는 것이 아니라 새로운 시퀀스를 생성하여 반환하는 방식이다.

5. 이 방식을 쿼리 합성 방식이라고 하며 이는 예외를 다루는 코드 작성 방법에 큰 영향을 미친다. action이나 function이 예외를 일으키는 경우 데이터의 비일관성 문제를 피하기 어렵다. 1번처럼 말이다. 하지만 기존의 데이터를 수정하는 대신 새로운 데이터를 생성하도록 코드를 작성하면 작업이 완전히 완료됐는지를 확인 할 수있고, 또 문제가 생겼을 경우 프로그램의 상태를 변경하지 않을 수도 있다.

6. 지금까지의 내용은 메서드가 예외를 일으킬 가능성이 있는 경우 뿐 아니라, 멀티스레드 환경에서도 적용해볼 수 있는 내용이다. 람다표현식을 사용하는 경우 그 내부에서 예외가 발생했을 때 원인을 규명하기가 매우 어려워진다. 마지막 예처럼 필요한 작업을 복사본에 대해서 수행하고, 예외가 발생하지 않은 경우에 한해서 전체 시퀀스를 변경하는 방식은 유용하다!


##결론 

그러니까, 문제가 발생한 곳을 찾아 그곳의 문제를 해결하고 기존의 시퀀스를 통해 계속해서 작업을 하는 것이 아니라, 문제가 발생한 부분부터, 새로운 시퀀스를 생성하여 작업을 하고 작업이 된 시퀀스를 반환하는 것을 말한다. 이러한 쿼리 합성 방식으로 하게되면, 람다식을 사용하면서 발생하는 중간의 예외 발생 상황에서 좀 더 유연하게 대응할 수 있게 된다.
